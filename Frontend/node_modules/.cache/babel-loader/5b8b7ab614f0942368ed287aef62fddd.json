{"ast":null,"code":"const createImage = url => new Promise((resolve, reject) => {\n  const image = new Image();\n  image.addEventListener(\"load\", () => resolve(image));\n  image.addEventListener(\"error\", error => reject(error));\n  image.setAttribute(\"crossOrigin\", \"anonymous\"); // needed to avoid cross-origin issues on CodeSandbox\n\n  image.src = url;\n});\n\nfunction getRadianAngle(degreeValue) {\n  return degreeValue * Math.PI / 180;\n}\n\nasync function getCroppedImg(imageSrc, pixelCrop, rotation = 0) {\n  const image = await createImage(imageSrc);\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n  const maxSize = Math.max(image.width, image.height);\n  const safeArea = 2 * (maxSize / 2 * Math.sqrt(2)); // set each dimensions to double largest dimension to allow for a safe area for the\n  // image to rotate in without being clipped by canvas context\n\n  canvas.width = safeArea;\n  canvas.height = safeArea; // translate canvas context to a central location on image to allow rotating around the center.\n\n  ctx.translate(safeArea / 2, safeArea / 2);\n  ctx.rotate(getRadianAngle(rotation));\n  ctx.translate(-safeArea / 2, -safeArea / 2); // draw rotated image and store data.\n\n  ctx.drawImage(image, safeArea / 2 - image.width * 0.5, safeArea / 2 - image.height * 0.5);\n  const data = ctx.getImageData(0, 0, safeArea, safeArea); // set canvas width to final desired crop size - this will clear existing context\n\n  canvas.width = pixelCrop.width;\n  canvas.height = pixelCrop.height; // paste generated rotate image with correct offsets for x,y crop values.\n\n  ctx.putImageData(data, 0 - safeArea / 2 + image.width * 0.5 - pixelCrop.x, 0 - safeArea / 2 + image.height * 0.5 - pixelCrop.y); // As Base64 string\n  // return canvas.toDataURL(\"image/jpeg\");\n\n  return canvas;\n}\n\nexport const generateDownload = async (imageSrc, crop, callback) => {\n  if (!crop || !imageSrc) {\n    return;\n  }\n\n  const canvas = await getCroppedImg(imageSrc, crop);\n  canvas.toBlob(blob => {\n    const file = new File([blob], \"image.jpg\");\n    const previewUrl = window.URL.createObjectURL(blob);\n    callback(file, previewUrl);\n  }, \"image/jpeg\", 1);\n};","map":{"version":3,"sources":["D:/hihi/senior-project/web/src/lib/CropUtils.js"],"names":["createImage","url","Promise","resolve","reject","image","Image","addEventListener","error","setAttribute","src","getRadianAngle","degreeValue","Math","PI","getCroppedImg","imageSrc","pixelCrop","rotation","canvas","document","createElement","ctx","getContext","maxSize","max","width","height","safeArea","sqrt","translate","rotate","drawImage","data","getImageData","putImageData","x","y","generateDownload","crop","callback","toBlob","blob","file","File","previewUrl","window","URL","createObjectURL"],"mappings":"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","sourcesContent":["const createImage = (url) =>\r\n    new Promise((resolve, reject) => {\r\n        const image = new Image();\r\n        image.addEventListener(\"load\", () => resolve(image));\r\n        image.addEventListener(\"error\", (error) => reject(error));\r\n        image.setAttribute(\"crossOrigin\", \"anonymous\"); // needed to avoid cross-origin issues on CodeSandbox\r\n        image.src = url;\r\n    });\r\nfunction getRadianAngle(degreeValue) {\r\n    return (degreeValue * Math.PI) / 180;\r\n}\r\nasync function getCroppedImg(imageSrc, pixelCrop, rotation = 0) {\r\n    const image = await createImage(imageSrc);\r\n    const canvas = document.createElement(\"canvas\");\r\n    const ctx = canvas.getContext(\"2d\");\r\n\r\n    const maxSize = Math.max(image.width, image.height);\r\n    const safeArea = 2 * ((maxSize / 2) * Math.sqrt(2));\r\n\r\n    // set each dimensions to double largest dimension to allow for a safe area for the\r\n    // image to rotate in without being clipped by canvas context\r\n    canvas.width = safeArea;\r\n    canvas.height = safeArea;\r\n\r\n    // translate canvas context to a central location on image to allow rotating around the center.\r\n    ctx.translate(safeArea / 2, safeArea / 2);\r\n    ctx.rotate(getRadianAngle(rotation));\r\n    ctx.translate(-safeArea / 2, -safeArea / 2);\r\n\r\n    // draw rotated image and store data.\r\n    ctx.drawImage(\r\n        image,\r\n        safeArea / 2 - image.width * 0.5,\r\n        safeArea / 2 - image.height * 0.5\r\n    );\r\n\r\n    const data = ctx.getImageData(0, 0, safeArea, safeArea);\r\n\r\n    // set canvas width to final desired crop size - this will clear existing context\r\n    canvas.width = pixelCrop.width;\r\n    canvas.height = pixelCrop.height;\r\n\r\n    // paste generated rotate image with correct offsets for x,y crop values.\r\n    ctx.putImageData(\r\n        data,\r\n        0 - safeArea / 2 + image.width * 0.5 - pixelCrop.x,\r\n        0 - safeArea / 2 + image.height * 0.5 - pixelCrop.y\r\n    );\r\n\r\n    // As Base64 string\r\n    // return canvas.toDataURL(\"image/jpeg\");\r\n    return canvas;\r\n}\r\nexport const generateDownload = async (imageSrc, crop, callback) => {\r\n    if (!crop || !imageSrc) {\r\n        return;\r\n    }\r\n\r\n    const canvas = await getCroppedImg(imageSrc, crop);\r\n\r\n    canvas.toBlob(\r\n        (blob) => {\r\n            const file = new File([blob], \"image.jpg\");\r\n            const previewUrl = window.URL.createObjectURL(blob);            \r\n            callback(file,previewUrl);\r\n        },\r\n        \"image/jpeg\",\r\n        1\r\n    );\r\n};\r\n"]},"metadata":{},"sourceType":"module"}